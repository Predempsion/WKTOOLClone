// Generated by CoffeeScript 1.7.1
(function() {
  var ScalableModels, loadTaskGraph,
    __slice = [].slice;

  this.ScalableModels = ScalableModels = {};

  ScalableModels["Leader Election with N Processes"] = {
    defaults: [3],
    parameters: ["Number of processes in the ring, which must elect a leader."],
    factory: function(n) {
      var choices, desc, i, j, message, messages, msg, next, procs, properties, r, ring, _i, _j, _k, _l, _m, _n, _ref, _ref1;
      message = function(reciever, rank) {
        return "m" + reciever + "r" + rank;
      };
      messages = [];
      for (i = _i = 1; 1 <= n ? _i <= n : _i >= n; i = 1 <= n ? ++_i : --_i) {
        for (j = _j = 1; 1 <= n ? _j <= n : _j >= n; j = 1 <= n ? ++_j : --_j) {
          messages.push(message(i, j));
        }
      }
      messages = messages.join(', ');
      ring = "Ring := (" + ((function() {
        var _k, _results;
        _results = [];
        for (i = _k = 1; 1 <= n ? _k <= n : _k >= n; i = 1 <= n ? ++_k : --_k) {
          _results.push("P" + i);
        }
        return _results;
      })()).join(' | ') + ")\n";
      ring += "        \\ {" + messages + "};\n";
      procs = [];
      for (i = _k = 1; 1 <= n ? _k <= n : _k >= n; i = 1 <= n ? ++_k : --_k) {
        next = i === 1 ? n : i - 1;
        choices = ["<" + (message(next, i)) + "!,1>.P" + i];
        for (r = _l = 1; 1 <= n ? _l <= n : _l >= n; r = 1 <= n ? ++_l : --_l) {
          msg = message(i, r);
          if (r < i) {
            choices.push("<" + msg + ">.P" + i);
          } else if (i === r) {
            choices.push("<" + msg + ">.leader:0");
          } else {
            choices.push("<" + msg + ">.P" + i + "_" + r);
          }
        }
        procs.push("P" + i + " := " + (choices.join(' + ')) + ";\n");
        for (j = _m = _ref = i + 1, _ref1 = n + 1; _ref <= _ref1 ? _m < _ref1 : _m > _ref1; j = _ref <= _ref1 ? ++_m : --_m) {
          choices = ["<" + (message(next, j)) + "!,1>.P" + i + "_" + j, "<" + (message(i, i)) + ">.leader:0"];
          for (r = _n = 1; 1 <= n ? _n <= n : _n >= n; r = 1 <= n ? ++_n : --_n) {
            msg = message(i, r);
            if (i === r) {
              continue;
            }
            if (r <= j) {
              choices.push("<" + msg + ">.P" + i + "_" + j);
            } else {
              choices.push("<" + msg + ">.P" + i + "_" + r);
            }
          }
          procs.push("P" + i + "_" + j + " := " + (choices.join(' + ')) + ";\n");
        }
        procs.push('\n');
      }
      procs.push(ring);
      desc = ["#### Ring-based Leader Election Protocol", "# This example has processes P1 to P" + n + ", each process have several states denoted by process", "# name underscore largest rank received. E.g. P1_2 is P1 in a state where it has received a", "# message with rank 2.", "# Messages are on the form 'm:receiver r:rank'"].join('\n');
      properties = [
        {
          state: "Ring",
          formula: "#It is possible to elect a leader\nEF leader"
        }, {
          state: "Ring",
          formula: "#A leader can be elected within n*n messages\nEF[<=" + (n * n) + "] leader"
        }, {
          state: "Ring",
          formula: "#Two leaders cannot be elected simultaneously\nEF leader > 1"
        }
      ];
      return {
        name: "Leader Election with " + n + " Processes",
        model: {
          language: 'WCCS',
          definition: desc + "\n" + procs.join('')
        },
        properties: properties
      };
    }
  };

  ScalableModels["k-Semaphore with N processes"] = {
    defaults: [3, 5],
    parameters: ["Initial value of semaphore (ie. maximum number of processes in the critical section)", "Number of parallel processes"],
    factory: function(k, N) {
      var i;
      return {
        name: "" + k + "-Semaphore Example with " + N + " Threads",
        model: {
          language: 'WCCS',
          definition: [
            "#### Semaphore Example", "# In this is example a semaphore with an initial value of " + k + " ensures that at most " + k, "# of " + N + " parallel threads enter the critical section at the same time.", "# The semaphore has " + k + " cells, where each cell can be locked and unlocked.", "# The number of cells limits the access to the critical section.", "", "# System consists of a semaphore and a collection of threads", "System     := (Semaphore | Threads) \\ {lock, unlock};", "", "# A thread enters its critical section after locking, and exits by unlocking", "Thread     := <lock!>.critical_section:<unlock!>.Thread;", "", "# A semaphore cell (used for building a semaphore)", "Cell       := <lock>.<unlock>.Cell;", "", "# A semaphore with value counted by number of cells", "Semaphore  := " + (((function() {
              var _i, _results;
              _results = [];
              for (i = _i = 0; 0 <= k ? _i < k : _i > k; i = 0 <= k ? ++_i : --_i) {
                _results.push('Cell');
              }
              return _results;
            })()).join(' | ')) + ";", "", "# Threads is set of parallel threads", "Threads    := " + (((function() {
              var _i, _results;
              _results = [];
              for (i = _i = 0; 0 <= N ? _i < N : _i > N; i = 0 <= N ? ++_i : --_i) {
                _results.push('Thread');
              }
              return _results;
            })()).join(' | ')) + ";"
          ].join('\n')
        },
        properties: [
          {
            state: "System",
            formula: "# There cannot be more than " + k + " threads in the critical section\nEF critical_section > " + k
          }, {
            state: "System",
            formula: "# There can be " + k + " threads in the critical section\nEF critical_section == " + k
          }
        ]
      };
    }
  };

  ScalableModels["k-Buffered Alternating Bit Protocol"] = {
    defaults: [4, 5],
    parameters: ["Size of lossy buffer", "Number of messages to deliver"],
    factory: function(k, n) {
      var i, model;
      model = {
        name: "" + k + "-Buffered Alternating Bit Protocol",
        model: {
          language: 'WCCS',
          definition: ["#### Alternating Bit Protocol", "#", "# Channels:       From:       To:         Action:", "# <transmitx>     Sender      Medium      Send x", "# <rackx>         Medium      Sender      Receive ack x", "# <rx>            Medium      Receive     Receive x", "# <sackx>         Receive     Medium      Send ack x", "# <deliver>", "", "# Sender", "Sender   := Ready0;", "Ready0   := <send>.Sending0;", "Ready1   := <send>.Sending1;", "Sending0 := <transmit0!>.send0:(<rack0>.Ready1 + <rack1>.Sending0 + <tau>.Sending0);", "Sending1 := <transmit1!>.send1:(<rack1>.Ready0 + <rack0>.Sending1 + <tau>.Sending1);", "", "# Receiver", "Receiver := Receive0;", "Receive0 := <r0>.<deliver!>.deliver0:<sack0!>.Receive1 + <r1>.<sack1!>.Receive0 + <tau>.<sack1!>.Receive0;", "Receive1 := <r1>.<deliver!>.deliver1:<sack1!>.Receive0 + <r0>.<sack0!>.Receive1 + <tau>.<sack0!>.Receive1;", "", "# Lossy Buffer (as shift register)", "# Buffer holds one bit", "BufferCell := <in0>.(<out0!,1>.BufferCell + BufferCell) + <in1>.(<out1!,1>.BufferCell + BufferCell);", "", "# Scaling of buffer", "Buffer1  := BufferCell;"].concat(__slice.call(((function() {
              var _i, _results;
              _results = [];
              for (i = _i = 2; 2 <= k ? _i <= k : _i >= k; i = 2 <= k ? ++_i : --_i) {
                _results.push(["Buffer" + i + "  := (Buffer" + (Math.floor(i / 2)) + "[out0 -> shift0, out1 -> shift1] | ", "Buffer" + (Math.ceil(i / 2)) + "[in0 -> shift0, in1 -> shift1]) \\ {shift0, shift1};"].join(''));
              }
              return _results;
            })())), [""], ["# Lossy Medium"], ["Medium   := MediumSR | MediumRS;"], ["MediumSB := <transmit0>.<in0!>.MediumSB + <transmit1>.<in1!>.MediumSB;"], ["MediumBR := <out0>.<r0!>.MediumBR + <out1>.<r1!>.MediumBR;"], ["MediumSR := (MediumSB | Buffer" + k + " | MediumBR) \\ {in0, in1, out0, out1};"], [""], ["MediumRS := <sack0>.(<rack0!>.MediumRS + MediumRS) + <sack1>.(<rack1!>.MediumRS + MediumRS);"], [""], ["# User-space"], ["UserSpace := " + (((function() {
              var _i, _results;
              _results = [];
              for (i = _i = 0; 0 <= n ? _i < n : _i > n; i = 0 <= n ? ++_i : --_i) {
                _results.push('D');
              }
              return _results;
            })()).join(' | ')) + ";"], ["D := <deliver>.delivered:0;"], [""], ["System := (Sender | Medium | Receiver | UserSpace)"], ["          \\ {transmit0, transmit1, rack0, rack1, r0, r1, sack0, sack1, deliver};"]).join('\n')
        },
        properties: [
          {
            state: "System",
            formula: "# We can have " + n + " messages delivered \nEF[<= " + (k * n) + "] delivered == " + n
          }, {
            state: "System",
            formula: "# We deliver the same bit that was sent\nEF (send0 && deliver1) || (send1 && deliver0)"
          }
        ]
      };
      return model;
    }
  };

  ScalableModels["Standard Task Graph"] = {
    defaults: [0, 10],
    parameters: ["Model number (0 - 179)", "Number of tasks"],
    factory: function(m, N) {
      var def;
      def = loadTaskGraph(Math.min(m, 179), Math.min(N, 50));
      if (def == null) {
        return null;
      }
      return {
        name: "Task Graph #" + (Math.min(m, 179)) + " - " + (Math.min(N, 50)) + " tasks",
        model: {
          language: 'WCCS',
          definition: [def, "", "# Processor", "Processors := P1 | P2;", "", "# Processor units 1 and 2", "P1 := <tick,1>.<e1!>.P1;", "P2 := <tick!,1>.<e2!>.P2;", "", "System := (Processors | Tasks) \\ {e1, e2};"].join('\n')
        },
        properties: [
          {
            state: "System",
            formula: "# Once T" + (Math.max(N - 2, 1)) + " is ready, all tasks eventually finish\nEF[<=90] (t" + (Math.max(N - 2, 1)) + "_ready && AF[<= 80] done == " + (N + 2) + ")"
          }, {
            state: "System",
            formula: "# After 10 ticks, T" + (Math.max(N - 2, 1)) + " is ready, all tasks eventually finish\nEF[<=10] (t" + (Math.max(N - 2, 1)) + "_ready && AF[<=5] done == " + (N + 2) + ")"
          }, {
            state: "System",
            formula: "# All tasks can complete\nEF done == " + (N + 2)
          }
        ]
      };
    }
  };

  loadTaskGraph = function(model, number) {
    var data, dep, depend, deps, exec, exetime, filename, formatNumber, i, line, lines, num_deps, offset, range, result, row, task, _i, _len, _ref;
    formatNumber = function(num, zeroes) {
      var s;
      s = num + "";
      while (s.length < zeroes) {
        s = "0" + s;
      }
      return s;
    };
    filename = formatNumber(model, 4);
    data = fetchTaskGraph("/examples/TaskGraphs50/rand" + filename + ".stg");
    if (data == null) {
      ShowMessage("Error: Failed to load task graph file!");
      return null;
    }
    result = [];
    lines = data.split("\n");
    offset = 3;
    range = number + offset;
    _ref = lines.slice(1, range);
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      line = _ref[_i];
      if (line[0] !== '#') {
        row = line.replace(/\s+/g, ' ').split(' ');
        i = row[1];
        exetime = parseInt(row[2]);
        num_deps = parseInt(row[3]);
        deps = row.slice(4, row.length);
        exec = function(core, t) {
          var x;
          return ((function() {
            var _j, _results;
            _results = [];
            for (x = _j = 0; 0 <= t ? _j < t : _j > t; x = 0 <= t ? ++_j : --_j) {
              _results.push("<e" + core + ">");
            }
            return _results;
          })()).join('.');
        };
        depend = ((function() {
          var _j, _len1, _results;
          _results = [];
          for (_j = 0, _len1 = deps.length; _j < _len1; _j++) {
            dep = deps[_j];
            _results.push("<t" + dep + "d>");
          }
          return _results;
        })()).join('.');
        if (deps.length > 0) {
          depend += ".";
        }
        if (exetime > 0) {
          task = "T" + i + " := " + depend + "t" + i + "_ready:(" + (exec(1, exetime)) + ".T" + i + "D + " + (exec(2, exetime)) + ".T" + i + "D);";
        } else {
          task = "T" + i + " := " + depend + "T" + i + "D;";
        }
        task += "\nT" + i + "D := done:<t" + i + "d!>.T" + i + "D;\n";
        result.push(task);
      }
    }
    result.push("Tasks := (" + (((function() {
      var _j, _ref1, _results;
      _results = [];
      for (i = _j = 0, _ref1 = range - 1; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
        _results.push("T" + i);
      }
      return _results;
    })()).join(" | ")) + ") \\ {" + (((function() {
      var _j, _ref1, _results;
      _results = [];
      for (i = _j = 0, _ref1 = range - 1; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
        _results.push("t" + i + "d");
      }
      return _results;
    })()).join(", ")) + "};");
    return result.join('\n');
  };

}).call(this);
