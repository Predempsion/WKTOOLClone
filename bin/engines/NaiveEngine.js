// Generated by CoffeeScript 1.7.1
(function() {
  var Configuration, HyperEdge, nextId, _nId, _nb_hyps;

  _nId = 0;

  nextId = function() {
    return _nId++;
  };

  Configuration = (function() {
    function Configuration(state, formula) {
      this.state = state;
      this.formula = formula;
      this.value = null;
      this.deps = [];
      this.id = nextId();
    }

    Configuration.prototype.stringify = function() {
      return "[" + (state.name()) + ", " + (this.formula.stringify()) + "]";
    };

    Configuration.prototype.dep = function(edge) {
      var e, _i, _len, _ref;
      _ref = this.deps;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        e = _ref[_i];
        if (e === edge) {
          return;
        }
      }
      this.deps.push(edge);
    };

    return Configuration;

  })();

  _nb_hyps = 0;

  HyperEdge = (function() {
    function HyperEdge(source, targets) {
      this.source = source;
      this.targets = targets;
      _nb_hyps++;
      this.in_queue = true;
    }

    HyperEdge.prototype.stringify = function() {
      var t, tlist;
      if (this.targets.length !== 0) {
        tlist = ((function() {
          var _i, _len, _ref, _results;
          _ref = this.targets;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            t = _ref[_i];
            _results.push(t.stringify());
          }
          return _results;
        }).call(this)).sort();
        return "" + (this.source.stringify()) + " -> " + (tlist.join(', '));
      } else {
        return "" + (this.source.stringify()) + " -> Ã˜";
      }
    };

    return HyperEdge;

  })();

  this.NaiveEngine = (function() {
    function NaiveEngine(formula, initState) {
      this.formula = formula;
      this.initState = initState;
      this.nb_confs = 0;
    }

    NaiveEngine.prototype.local = function(exp_stats, queue) {
      var e, edge, i, isTrue, iterations, max_queue, queue_size, queue_size_count, queue_size_i, queue_size_interval, queue_sizes, retval, state, target, v0, _i, _j, _k, _len, _len1, _ref, _ref1;
      _nb_hyps = 0;
      state = this.initState;
      v0 = this.getConf(state, this.formula);
      this.queue = queue = new queue();
      if (v0.value === null) {
        v0.value = false;
        v0.formula.naiveExpand(v0, this);
      }
      iterations = 0;
      max_queue = 1;
      queue_sizes = [];
      queue_size_interval = 1;
      queue_size_count = 1;
      queue_size_i = 0;
      while (!queue.empty()) {
        if (exp_stats) {
          queue_size = queue.size();
          if (max_queue < queue_size) {
            max_queue = queue_size;
          }
          queue_size_count -= 1;
          if (queue_size_count === 0) {
            queue_sizes[queue_size_i++] = queue_size;
            if (queue_size_i > 100) {
              queue_size_i = 0;
              for (i = _i = 0; _i < 100; i = _i += 5) {
                queue_sizes[queue_size_i++] = queue_sizes[i];
              }
              queue_size_interval *= 5;
            }
            queue_size_count = queue_size_interval;
          }
        }
        iterations++;
        e = queue.pop();
        e.in_queue = false;
        isTrue = true;
        _ref = e.targets;
        for (_j = 0, _len = _ref.length; _j < _len; _j++) {
          target = _ref[_j];
          if (target.value === true) {
            continue;
          }
          isTrue = false;
          if (target.value === false) {
            target.dep(e);
            break;
          }
          if (target.value === null) {
            target.value = false;
            target.dep(e);
            target.formula.naiveExpand(target, this);
            break;
          }
        }
        if (isTrue && !e.source.value) {
          e.source.value = true;
          _ref1 = e.source.deps;
          for (_k = 0, _len1 = _ref1.length; _k < _len1; _k++) {
            edge = _ref1[_k];
            queue.push_dep(edge);
          }
          if (e.source === v0) {
            break;
          }
        }
      }
      retval = {
        result: v0.value === true,
        'Hyper-edges': _nb_hyps,
        'Configurations': this.nb_confs,
        'Iterations': iterations
      };
      if (exp_stats) {
        retval['Queue size'] = {
          sparklines: queue_sizes.slice(0, queue_size_i),
          value: ", max " + max_queue,
          options: {
            chartRangeMin: 0,
            tooltipFormat: "{{y}} edges in queue in the {{x}}'th iteration"
          }
        };
      }
      return retval;
    };

    NaiveEngine.prototype.global = function(exp_stats) {
      var c, c0, changes, confs, cstat_count, cstat_i, cstat_interval, cstat_table, e, fresh, i, iterations, opts, retval, s, state, val, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _m, _n, _ref, _ref1, _ref2, _ref3;
      _nb_hyps = 0;
      state = this.initState;
      c0 = this.getConf(state, this.formula);
      confs = [c0];
      fresh = [c0];
      while (fresh.length !== 0) {
        c = fresh.pop();
        this.queue = [];
        c.formula.naiveExpand(c, this);
        c.succ = this.queue;
        this.queue = null;
        _ref = c.succ;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          e = _ref[_i];
          _ref1 = e.targets;
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            s = _ref1[_j];
            if (s.explored == null) {
              s.explored = true;
              confs.push(s);
              fresh.push(s);
            }
          }
        }
        c.value = false;
      }
      changes = 1;
      cstat_table = [];
      cstat_interval = 1;
      cstat_count = 1;
      cstat_i = 0;
      iterations = 0;
      while (changes > 0 && c0.value === false) {
        changes = 0;
        for (_k = 0, _len2 = confs.length; _k < _len2; _k++) {
          c = confs[_k];
          if (c.value) {
            continue;
          }
          _ref2 = c.succ;
          for (_l = 0, _len3 = _ref2.length; _l < _len3; _l++) {
            e = _ref2[_l];
            val = true;
            _ref3 = e.targets;
            for (_m = 0, _len4 = _ref3.length; _m < _len4; _m++) {
              s = _ref3[_m];
              val = val && s.value;
            }
            if (val) {
              changes += 1;
              c.value = val;
              break;
            }
          }
        }
        if (exp_stats) {
          cstat_count -= 1;
          if (cstat_count === 0) {
            cstat_table[cstat_i++] = changes;
            if (cstat_i > 100) {
              cstat_i = 0;
              for (i = _n = 0; _n < 100; i = _n += 5) {
                cstat_table[cstat_i++] = cstat_table[i];
              }
              cstat_interval *= 5;
            }
            cstat_count = cstat_interval;
          }
        }
        iterations++;
      }
      retval = {
        result: c0.value === true,
        'Hyper-edges': _nb_hyps,
        'Configurations': this.nb_confs,
        'Iterations': iterations
      };
      if (exp_stats) {
        opts = {
          chartRangeMin: 0,
          tooltipFormat: "iteration with {{value}} changes"
        };
        if (cstat_interval === 1) {
          opts['type'] = 'bar';
        }
        retval['Changes / Iteration'] = {
          sparklines: cstat_table.slice(0, cstat_i),
          options: opts
        };
      }
      return retval;
    };

    NaiveEngine.prototype.getConf = function(state, formula) {
      var sH, val;
      sH = state.confs != null ? state.confs : state.confs = {};
      val = sH[formula.id];
      if (val == null) {
        this.nb_confs++;
        sH[formula.id] = val = new Configuration(state, formula);
      }
      return val;
    };

    return NaiveEngine;

  })();

  WCTL.BoolExpr.prototype.naiveExpand = function(conf, ctx) {
    if (conf.formula.value) {
      ctx.queue.push(new HyperEdge(conf, []));
    }
  };

  WCTL.AtomicExpr.prototype.naiveExpand = function(conf, ctx) {
    if (conf.formula.negated) {
      if (!conf.state.hasProp(conf.formula.prop)) {
        ctx.queue.push(new HyperEdge(conf, []));
      }
    } else if (!conf.formula.negated && conf.state.hasProp(conf.formula.prop)) {
      ctx.queue.push(new HyperEdge(conf, []));
    }
  };

  WCTL.OperatorExpr.prototype.naiveExpand = function(conf, ctx) {
    if (conf.formula.operator === WCTL.operator.AND) {
      ctx.queue.push(new HyperEdge(conf, [ctx.getConf(conf.state, conf.formula.expr1), ctx.getConf(conf.state, conf.formula.expr2)]));
    } else if (conf.formula.operator === WCTL.operator.OR) {
      ctx.queue.push(new HyperEdge(conf, [ctx.getConf(conf.state, conf.formula.expr1)]), new HyperEdge(conf, [ctx.getConf(conf.state, conf.formula.expr2)]));
    } else {
      throw "Operator must be either AND or OR";
    }
  };

  WCTL.UntilUpperExpr.prototype.naiveExpand = function(conf, ctx) {
    var bound, branches, expr1, expr2, quant, state, _ref;
    state = conf.state;
    _ref = conf.formula, quant = _ref.quant, expr1 = _ref.expr1, expr2 = _ref.expr2, bound = _ref.bound;
    if (bound < 0) {
      return;
    }
    ctx.queue.push(new HyperEdge(conf, [ctx.getConf(state, expr2)]));
    if (quant === WCTL.quant.E) {
      state.next(function(weight, target) {
        return ctx.queue.push(new HyperEdge(conf, [ctx.getConf(state, expr1), ctx.getConf(target, conf.formula.reduce(weight))]));
      });
    } else if (quant === WCTL.quant.A) {
      branches = [];
      state.next(function(weight, target) {
        return branches.push(ctx.getConf(target, conf.formula.reduce(weight)));
      });
      if (branches.length > 0) {
        branches.push(ctx.getConf(state, expr1));
        ctx.queue.push(new HyperEdge(conf, branches));
      }
    } else {
      throw "Unknown quantifier " + quant;
    }
  };

  WCTL.WeakUntilExpr.prototype.naiveExpand = function() {
    throw new Error("Weak until with lower bounds not supported by this engine");
  };

  WCTL.NextExpr.prototype.naiveExpand = function(conf, ctx) {
    var bound, branches, expr, quant, state, _ref;
    state = conf.state;
    _ref = conf.formula, quant = _ref.quant, expr = _ref.expr, bound = _ref.bound;
    if (bound < 0) {
      return;
    }
    if (quant === WCTL.quant.E) {
      state.next(function(w, t) {
        if (w <= bound) {
          return ctx.queue.push(new HyperEdge(conf, [ctx.getConf(t, expr)]));
        }
      });
    } else if (quant === WCTL.quant.A) {
      branches = [];
      state.next(function(weight, target) {
        if (weight <= bound) {
          return branches.push(ctx.getConf(target, expr));
        }
      });
      if (branches.length > 0) {
        ctx.queue.push(new HyperEdge(conf, branches));
      }
    } else {
      throw "Unknown quantifier " + quant;
    }
  };

  WCTL.NotExpr.prototype.naiveExpand = function() {
    throw new Error("Negation operator not supported by this engine");
  };

  WCTL.ComparisonExpr.prototype.naiveExpand = function(conf, ctx) {
    var v1, v2;
    v1 = this.expr1.evaluate(conf.state);
    v2 = this.expr2.evaluate(conf.state);
    if (this.cmpOp(v1, v2)) {
      ctx.queue.push(new HyperEdge(conf, []));
    }
  };

}).call(this);
