// Generated by CoffeeScript 1.7.1
(function() {
  var IntermediateExpr, Node, Queues, TernaryEdge, WeightedEdge, getNode,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Node = (function() {
    function Node(state, assertion, formula) {
      this.state = state;
      this.assertion = assertion;
      this.formula = formula;
      this.value = Infinity;
      this.expanded = false;
      this.min = true;
      this.targets = null;
      this.deps = [];
      this.queue_number = 0;
      this.in_queue = false;
    }

    Node.prototype.level = function() {
      return this.formula.level;
    };

    Node.prototype.expand = function() {
      if (!this.expanded) {
        this.expanded = true;
        this.formula.mmExpand(this);
        return true;
      }
      return false;
    };

    Node.prototype.depends = function(node) {
      if (__indexOf.call(this.deps, node) < 0) {
        this.deps.push(node);
      }
    };

    return Node;

  })();

  Queues = null;

  WeightedEdge = (function() {
    function WeightedEdge(weight, target) {
      this.weight = weight;
      this.target = target;
    }

    WeightedEdge.prototype.result = function() {
      return this.target.value + this.weight;
    };

    WeightedEdge.prototype.res = function() {
      return this.target.value + this.weight;
    };

    WeightedEdge.prototype.finished = function(u) {
      return (u.level() === this.target.level()) || (this.target.expanded && Queues[this.target.level()].empty());
    };

    return WeightedEdge;

  })();

  TernaryEdge = (function() {
    function TernaryEdge(k, w1, w2, target) {
      this.k = k;
      this.w1 = w1;
      this.w2 = w2;
      this.target = target;
    }

    TernaryEdge.prototype.res = function() {
      if (this.target.value < this.k) {
        return this.w1;
      }
      return this.w2;
    };

    TernaryEdge.prototype.result = function() {
      if (this.target.value < this.k) {
        return this.w1;
      }
      if (this.target.expanded && Queues[this.target.level()].empty()) {
        return this.w2;
      }
      return Math.max(this.w1, this.w2);
    };

    TernaryEdge.prototype.finished = function() {
      return (this.target.expanded && Queues[this.target.level()].empty()) || this.target.value < this.k;
    };

    return TernaryEdge;

  })();

  getNode = function(state, assertion, formula) {
    var node, tbl;
    if (assertion) {
      tbl = state.__Tnodes != null ? state.__Tnodes : state.__Tnodes = {};
    } else {
      tbl = state.__Fnodes != null ? state.__Fnodes : state.__Fnodes = {};
    }
    node = tbl[formula.id];
    if (node == null) {
      tbl[formula.id] = node = new Node(state, assertion, formula);
    }
    return node;
  };

  this.MinMaxEngine = (function() {
    function MinMaxEngine(formula, initState) {
      this.formula = formula;
      this.initState = initState;
    }

    MinMaxEngine.prototype.local = function(exp_stats, Queue) {
      var Q, Q0, Qj, Ql, d, edge, finished, j, l, maxj, res, u, v0, val, worst, worst_edge, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2;
      Queues = Q = [];
      this.formula.setLevel(0);
      v0 = getNode(this.initState, true, this.formula);
      v0.expand();
      Q[0] = Q0 = new Queue();
      Q0.push_dep(v0);
      j = 0;
      maxj = 1;
      while ((!Q0.empty()) && v0.value !== -Infinity) {
        j = (j + 1) % maxj;
        Qj = Q[j];
        if ((Qj == null) || Qj.empty()) {
          continue;
        }
        u = Qj.pop();
        u.in_queue = false;
        finished = true;
        if (u.min) {
          val = Infinity;
          _ref = u.targets || [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            edge = _ref[_i];
            res = edge.result();
            if (res < val) {
              val = edge.result();
            }
            if (edge.target.expand()) {
              l = edge.target.level();
              if (maxj < l + 1) {
                maxj = l + 1;
              }
              Ql = Q[l] != null ? Q[l] : Q[l] = new Queue();
              Ql.push_dep(edge.target);
              edge.target.depends(u);
            }
            finished = finished && edge.finished(u);
          }
        } else {
          val = -Infinity;
          worst = null;
          worst_edge = null;
          _ref1 = u.targets || [];
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            edge = _ref1[_j];
            res = edge.result();
            if (res > val) {
              val = edge.result();
              worst = edge.target;
              worst_edge = edge;
            }
          }
          if (worst != null) {
            if (worst.expand()) {
              l = worst.level();
              if (maxj < l + 1) {
                maxj = l + 1;
              }
              Ql = Q[l] != null ? Q[l] : Q[l] = new Queue();
              Ql.push_dep(worst);
            }
            finished = worst_edge.finished(u);
            worst.depends(u);
          }
        }
        if (!finished) {
          Qj.push_dep(u);
        }
        if (val < u.value) {
          u.value = val;
          _ref2 = u.deps;
          for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
            d = _ref2[_k];
            l = d.level();
            Q[l].push_dep(d);
          }
        }
      }
      return {
        result: v0.value === Infinity
      };
    };

    MinMaxEngine.prototype.global = function(exp_stats) {
      var Qj, Qs, W, edge, finished, j, l, maxj, u, v, v0, val, _i, _j, _k, _l, _len, _len1, _len2, _len3, _m, _ref, _ref1, _ref2;
      this.formula.setLevel(0);
      maxj = 0;
      v0 = getNode(this.initState, true, this.formula);
      Qs = [];
      Qs[0] = [v0];
      W = [v0];
      while (W.length !== 0) {
        u = W.pop();
        if (u.expand()) {
          _ref = u.targets || [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            edge = _ref[_i];
            W.push(edge.target);
            l = edge.target.level();
            if (Qs[l] == null) {
              Qs[l] = [];
            }
            Qs[l].push(edge.target);
            if (maxj < l) {
              maxj = l;
            }
          }
        }
      }
      for (j = _j = maxj; maxj <= 0 ? _j <= 0 : _j >= 0; j = maxj <= 0 ? ++_j : --_j) {
        Qj = Qs[j];
        finished = true;
        while (finished) {
          finished = false;
          for (_k = 0, _len1 = Qj.length; _k < _len1; _k++) {
            u = Qj[_k];
            if (u.min) {
              val = Infinity;
              _ref1 = u.targets || [];
              for (_l = 0, _len2 = _ref1.length; _l < _len2; _l++) {
                edge = _ref1[_l];
                v = edge.res();
                if (val > v) {
                  val = v;
                }
              }
            } else {
              val = -Infinity;
              _ref2 = u.targets || [];
              for (_m = 0, _len3 = _ref2.length; _m < _len3; _m++) {
                edge = _ref2[_m];
                v = edge.res();
                if (val < v) {
                  val = v;
                }
              }
            }
            if (val < u.value) {
              u.value = val;
              finished = true;
            }
          }
          if (v0.value === -Infinity) {
            break;
          }
        }
      }
      return {
        result: v0.value === Infinity
      };
    };

    return MinMaxEngine;

  })();

  IntermediateExpr = (function(_super) {
    __extends(IntermediateExpr, _super);

    function IntermediateExpr(level) {
      this.level = level;
    }

    return IntermediateExpr;

  })(WCTL.Expr);

  IntermediateExpr.prototype.mmExpand = function(node) {};

  WCTL.BoolExpr.prototype.mmExpand = function(node) {
    node.min = this.value === node.assertion;
  };

  WCTL.AtomicExpr.prototype.mmExpand = function(node) {
    node.min = node.assertion === ((!this.negated) === node.state.hasProp(this.prop));
  };

  WCTL.OperatorExpr.prototype.mmExpand = function(node) {
    var c1, c2;
    c1 = getNode(node.state, node.assertion, this.expr1);
    c2 = getNode(node.state, node.assertion, this.expr2);
    node.targets = [new WeightedEdge(0, c1), new WeightedEdge(0, c2)];
    node.min = node.assertion === (this.operator === WCTL.operator.AND);
  };

  WCTL.UntilUpperExpr.prototype.mmExpand = function(node) {
    var children, e2, ni, sign, state, sym_node;
    state = node.state;
    node.min = true;
    if (this.bound !== '?') {
      sym_node = getNode(state, false, this.abstract());
      sign = node.assertion - (!node.assertion);
      node.targets = [new TernaryEdge(this.bound + 1, sign * Infinity, sign * -Infinity, sym_node)];
      return;
    }
    e2 = new TernaryEdge(0, 0, Infinity, getNode(state, false, this.expr2));
    if (this.quant === WCTL.quant.E) {
      node.targets = [e2];
      state.next((function(_this) {
        return function(weight, target) {
          var ni;
          ni = new Node(null, null, new IntermediateExpr(_this.level));
          ni.min = false;
          ni.targets = [new WeightedEdge(0, getNode(state, false, _this.expr1)), new WeightedEdge(weight, getNode(target, false, _this))];
          return node.targets.push(new WeightedEdge(0, ni));
        };
      })(this));
      return;
    } else if (this.quant === WCTL.quant.A) {
      node.targets = [e2];
      children = [];
      state.next((function(_this) {
        return function(weight, target) {
          children.push(new WeightedEdge(weight, getNode(target, false, _this)));
        };
      })(this));
      if (children.length > 0) {
        ni = new Node(null, null, new IntermediateExpr(this.level));
        ni.min = false;
        children.push(new WeightedEdge(0, getNode(state, false, this.expr1)));
        ni.targets = children;
        node.targets.push(new WeightedEdge(0, ni));
      }
      return;
    } else {
      throw "Unknown quantifier " + this.quant;
    }
  };

  WCTL.WeakUntilExpr.prototype.mmExpand = function(node) {
    var children, e2, ni, sign, state, sym_node;
    state = node.state;
    node.min = false;
    if (this.bound !== '?') {
      sym_node = getNode(state, true, this.abstract());
      sign = (!node.assertion) - node.assertion;
      node.targets = [new TernaryEdge(this.bound + 1, sign * Infinity, sign * -Infinity, sym_node)];
      return;
    }
    e2 = new TernaryEdge(0, -Infinity, 0, getNode(state, true, this.expr2));
    if (this.quant === WCTL.quant.E) {
      node.targets = [e2];
      state.next((function(_this) {
        return function(weight, target) {
          var ni;
          ni = new Node(null, null, new IntermediateExpr(_this.level));
          ni.min = true;
          ni.targets = [new WeightedEdge(0, getNode(state, true, _this.expr1)), new WeightedEdge(weight, getNode(target, true, _this))];
          return node.targets.push(new WeightedEdge(0, ni));
        };
      })(this));
      return;
    } else if (this.quant === WCTL.quant.A) {
      node.targets = [e2];
      children = [];
      state.next((function(_this) {
        return function(weight, target) {
          children.push(new WeightedEdge(weight, getNode(target, true, _this)));
        };
      })(this));
      if (children.length > 0) {
        ni = new Node(null, null, new IntermediateExpr(this.level));
        ni.min = true;
        children.push(new WeightedEdge(0, getNode(state, true, this.expr1)));
        ni.targets = children;
        node.targets.push(new WeightedEdge(0, ni));
      }
      return;
    } else {
      throw "Unknown quantifier " + this.quant;
    }
  };

  WCTL.NextExpr.prototype.mmExpand = function(node) {
    var state;
    state = node.state;
    node.targets = [];
    state.next((function(_this) {
      return function(weight, target) {
        if ((_this.re === '<' && weight < _this.bound) || (_this.re === '>' && weight > _this.bound)) {
          node.targets.push(new WeightedEdge(0, getNode(target, node.assertion, _this.expr)));
        }
      };
    })(this));
    if (node.targets.length === 0) {
      node.targets = null;
    }
    node.min = node.assertion === (this.quant === WCTL.quant.A);
  };

  WCTL.NotExpr.prototype.mmExpand = function(node) {
    node.min = true;
    node.targets = [new WeightedEdge(0, getNode(node.state, !node.assertion, this.expr))];
  };

  WCTL.ComparisonExpr.prototype.mmExpand = function(node) {
    var v1, v2;
    v1 = this.expr1.evaluate(node.state);
    v2 = this.expr2.evaluate(node.state);
    node.min = this.cmpOp(v1, v2) === node.assertion;
  };

}).call(this);
