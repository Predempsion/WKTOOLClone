// Generated by CoffeeScript 1.7.1
(function() {
  var WCTL, binOpToString, cmpOpToString, _nextId,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  _nextId = 0;

  this.WCTL = WCTL = {};

  this.WCTL.Context = (function() {
    function Context() {
      this._atomicNegCache = {};
      this._atomicCache = {};
      this._aatomicCache = {};
      this._aconstantCache = {};
    }

    Context.prototype.BoolExpr = function(bool) {
      if (bool === true) {
        return this._boolTrue != null ? this._boolTrue : this._boolTrue = new WCTL.BoolExpr(true);
      }
      return this._boolFalse != null ? this._boolFalse : this._boolFalse = new WCTL.BoolExpr(false);
    };

    Context.prototype.AtomicExpr = function(prop, negated) {
      var _base, _base1;
      if (negated == null) {
        negated = false;
      }
      if (!negated) {
        return (_base = this._atomicCache)[prop] != null ? _base[prop] : _base[prop] = new WCTL.AtomicExpr(prop);
      }
      return (_base1 = this._atomicNegCache)[prop] != null ? _base1[prop] : _base1[prop] = new WCTL.AtomicExpr(prop, true);
    };

    Context.prototype.OperatorExpr = function(operator, expr1, expr2) {
      var cache, tmp, _name;
      if (expr1.id < expr2.id) {
        tmp = expr2;
        expr2 = expr1;
        expr1 = tmp;
      }
      cache = expr1._opCache != null ? expr1._opCache : expr1._opCache = {};
      return cache[_name = operator + " " + expr2.stringify()] != null ? cache[_name] : cache[_name] = new WCTL.OperatorExpr(operator, expr1, expr2);
    };

    Context.prototype.UntilUpperExpr = function(quant, expr1, expr2, bound) {
      var cache, _name;
      cache = expr1._untilUpperCache != null ? expr1._untilUpperCache : expr1._untilUpperCache = {};
      return cache[_name = quant + ("[<" + bound + "]") + expr2.stringify()] != null ? cache[_name] : cache[_name] = new WCTL.UntilUpperExpr(quant, expr1, expr2, bound, this);
    };

    Context.prototype.WeakUntilExpr = function(quant, expr1, expr2, bound) {
      var cache, _name;
      cache = expr1._weakUntilCache != null ? expr1._weakUntilCache : expr1._weakUntilCache = {};
      return cache[_name = quant + ("[>" + bound + "]") + expr2.stringify()] != null ? cache[_name] : cache[_name] = new WCTL.WeakUntilExpr(quant, expr1, expr2, bound, this);
    };

    Context.prototype.NextExpr = function(quant, expr, bound) {
      var cache, _name;
      cache = expr._nextCache != null ? expr._nextCache : expr._nextCache = {};
      return cache[_name = quant + ("[" + bound.re + bound.bound + "]")] != null ? cache[_name] : cache[_name] = new WCTL.NextExpr(quant, expr, bound);
    };

    Context.prototype.NotExpr = function(expr) {
      return expr._notCache != null ? expr._notCache : expr._notCache = new WCTL.NotExpr(expr);
    };

    Context.prototype.ComparisonExpr = function(expr1, expr2, cmpOp) {
      var cache, _name;
      cache = expr1._cmpCache != null ? expr1._cmpCache : expr1._cmpCache = {};
      return cache[_name = cmpOpToString(cmpOp) + expr2.stringify()] != null ? cache[_name] : cache[_name] = new WCTL.ComparisonExpr(expr1, expr2, cmpOp);
    };

    Context.prototype.AAtomicExpr = function(value) {
      var _base;
      return (_base = this._aatomicCache)[value] != null ? _base[value] : _base[value] = new WCTL.Arithmetic.AtomicExpr(value);
    };

    Context.prototype.ABinaryExpr = function(expr1, expr2, operator) {
      var cache, _name;
      cache = expr1._abinCache != null ? expr1._abinCache : expr1._abinCache = {};
      return cache[_name = binOpToString(operator) + expr2.stringify()] != null ? cache[_name] : cache[_name] = new WCTL.Arithmetic.BinaryExpr(expr1, expr2, operator);
    };

    Context.prototype.AConstantExpr = function(number) {
      var _base;
      return (_base = this._aconstantCache)[number] != null ? _base[number] : _base[number] = new WCTL.Arithmetic.ConstantExpr(number);
    };

    Context.prototype.AUnaryMinusExpr = function(expr) {
      return expr._unaryCache != null ? expr._unaryCache : expr._unaryCache = new WCTL.Arithmetic.UnaryMinusExpr(expr);
    };

    return Context;

  })();

  WCTL.Expr = (function() {
    function Expr() {
      this.id = _nextId++;
      this.level = -1;
    }

    Expr.prototype.stringify = function() {
      throw "Must override stringify in subclasses";
    };

    Expr.prototype.setLevel = function(level) {
      throw "Must override stringify in subclasses";
    };

    return Expr;

  })();

  WCTL.BoolExpr = (function(_super) {
    __extends(BoolExpr, _super);

    function BoolExpr(value) {
      this.value = value;
      BoolExpr.__super__.constructor.call(this);
    }

    BoolExpr.prototype.stringify = function() {
      return "" + this.value;
    };

    BoolExpr.prototype.setLevel = function(l) {
      if (l == null) {
        l = 0;
      }
      if (this.level < l) {
        return this.level = l;
      }
    };

    return BoolExpr;

  })(WCTL.Expr);

  WCTL.AtomicExpr = (function(_super) {
    __extends(AtomicExpr, _super);

    function AtomicExpr(prop, negated) {
      this.prop = prop;
      this.negated = negated != null ? negated : false;
      AtomicExpr.__super__.constructor.call(this);
    }

    AtomicExpr.prototype.stringify = function() {
      return "" + (this.negated ? '!' : '') + this.prop;
    };

    AtomicExpr.prototype.setLevel = function(l) {
      if (l == null) {
        l = 0;
      }
      if (this.level < l) {
        return this.level = l;
      }
    };

    return AtomicExpr;

  })(WCTL.Expr);

  WCTL.operator = {
    AND: 'AND',
    OR: 'OR'
  };

  WCTL.OperatorExpr = (function(_super) {
    __extends(OperatorExpr, _super);

    function OperatorExpr(operator, expr1, expr2) {
      this.operator = operator;
      this.expr1 = expr1;
      this.expr2 = expr2;
      OperatorExpr.__super__.constructor.call(this);
    }

    OperatorExpr.prototype.stringify = function() {
      return "(" + (this.expr1.stringify()) + " " + this.operator + " " + (this.expr2.stringify()) + ")";
    };

    OperatorExpr.prototype.setLevel = function(l) {
      if (l == null) {
        l = 0;
      }
      if (this.level < l) {
        this.level = l;
        this.expr1.setLevel(l);
        return this.expr2.setLevel(l);
      }
    };

    return OperatorExpr;

  })(WCTL.Expr);

  WCTL.quant = {
    E: 'E',
    A: 'A'
  };

  WCTL.UntilUpperExpr = (function(_super) {
    __extends(UntilUpperExpr, _super);

    function UntilUpperExpr(quant, expr1, expr2, bound, ctx) {
      this.quant = quant;
      this.expr1 = expr1;
      this.expr2 = expr2;
      this.bound = bound;
      this.ctx = ctx;
      UntilUpperExpr.__super__.constructor.call(this);
    }

    UntilUpperExpr.prototype.stringify = function() {
      return "(" + this.quant + " " + (this.expr1.stringify()) + " U[<" + this.bound + "] " + (this.expr2.stringify()) + ")";
    };

    UntilUpperExpr.prototype.reduce = function(weight) {
      if (weight === 0) {
        return this;
      }
      return this.ctx.UntilUpperExpr(this.quant, this.expr1, this.expr2, this.bound - weight);
    };

    UntilUpperExpr.prototype.abstract = function() {
      return this.ctx.UntilUpperExpr(this.quant, this.expr1, this.expr2, "?");
    };

    UntilUpperExpr.prototype.setLevel = function(l) {
      if (l == null) {
        l = 0;
      }
      if (this.level < l) {
        this.level = l;
        if (this.bound !== '?') {
          return this.abstract().setLevel(l + 1);
        } else {
          this.expr1.setLevel(l + 1);
          return this.expr2.setLevel(l + 1);
        }
      }
    };

    return UntilUpperExpr;

  })(WCTL.Expr);

  WCTL.WeakUntilExpr = (function(_super) {
    __extends(WeakUntilExpr, _super);

    function WeakUntilExpr(quant, expr1, expr2, bound, ctx) {
      this.quant = quant;
      this.expr1 = expr1;
      this.expr2 = expr2;
      this.bound = bound;
      this.ctx = ctx;
      WeakUntilExpr.__super__.constructor.call(this);
    }

    WeakUntilExpr.prototype.stringify = function() {
      return "(" + this.quant + " " + (this.expr1.stringify()) + " W[>" + this.bound + "] " + (this.expr2.stringify()) + ")";
    };

    WeakUntilExpr.prototype.reduce = function(weight) {
      if (weight === 0) {
        return this;
      }
      return this.ctx.WeakUntilExpr(this.quant, this.expr1, this.expr2, this.bound - weight);
    };

    WeakUntilExpr.prototype.abstract = function() {
      return this.ctx.WeakUntilExpr(this.quant, this.expr1, this.expr2, "?");
    };

    WeakUntilExpr.prototype.setLevel = function(l) {
      if (l == null) {
        l = 0;
      }
      if (this.level < l) {
        this.level = l;
        if (this.bound !== '?') {
          return this.abstract().setLevel(l + 1);
        } else {
          this.expr1.setLevel(l + 1);
          return this.expr2.setLevel(l + 1);
        }
      }
    };

    return WeakUntilExpr;

  })(WCTL.Expr);

  WCTL.NextExpr = (function(_super) {
    __extends(NextExpr, _super);

    function NextExpr(quant, expr, _arg) {
      this.quant = quant;
      this.expr = expr;
      this.re = _arg.re, this.bound = _arg.bound;
      NextExpr.__super__.constructor.call(this);
    }

    NextExpr.prototype.stringify = function() {
      return "(" + this.quant + "X[" + this.re + this.bound + "] " + (this.expr.stringify()) + ")";
    };

    NextExpr.prototype.setLevel = function(l) {
      if (l == null) {
        l = 0;
      }
      if (this.level < l) {
        this.level = l;
        return this.expr.setLevel(l);
      }
    };

    return NextExpr;

  })(WCTL.Expr);

  WCTL.NotExpr = (function(_super) {
    __extends(NotExpr, _super);

    function NotExpr(expr) {
      this.expr = expr;
      NotExpr.__super__.constructor.call(this);
    }

    NotExpr.prototype.stringify = function() {
      return "!" + (this.expr.stringify()) + ")";
    };

    NotExpr.prototype.setLevel = function(l) {
      if (l == null) {
        l = 0;
      }
      if (this.level < l) {
        this.level = l;
        return this.expr.setLevel(l);
      }
    };

    return NotExpr;

  })(WCTL.Expr);

  WCTL.ComparisonExpr = (function(_super) {
    __extends(ComparisonExpr, _super);

    function ComparisonExpr(expr1, expr2, cmpOp) {
      this.expr1 = expr1;
      this.expr2 = expr2;
      this.cmpOp = cmpOp;
      ComparisonExpr.__super__.constructor.call(this);
    }

    ComparisonExpr.prototype.stringify = function() {
      return "(" + (this.expr1.stringify()) + " " + (cmpOpToString(this.cmpOp)) + " " + (this.expr2.stringify()) + ")";
    };

    ComparisonExpr.prototype.setLevel = function(l) {
      if (l == null) {
        l = 0;
      }
      if (this.level < l) {
        return this.level = l;
      }
    };

    return ComparisonExpr;

  })(WCTL.Expr);

  if (WCTL.Arithmetic == null) {
    WCTL.Arithmetic = {};
  }

  WCTL.Arithmetic.cmpOp = {
    '<': function(a, b) {
      return a < b;
    },
    '<=': function(a, b) {
      return a <= b;
    },
    '==': function(a, b) {
      return a === b;
    },
    '!=': function(a, b) {
      return a !== b;
    },
    '>': function(a, b) {
      return a > b;
    },
    '>=': function(a, b) {
      return a >= b;
    }
  };

  cmpOpToString = function(op) {
    var k, v, _ref;
    _ref = WCTL.Arithmetic.cmpOp;
    for (k in _ref) {
      v = _ref[k];
      if (v === op) {
        return k;
      }
    }
  };

  WCTL.Arithmetic.Expr = (function() {
    function Expr() {}

    Expr.prototype.stringify = function() {
      throw "Must override stringify in subclasses";
    };

    Expr.prototype.evaluate = function(state) {
      throw "Must override stringify in subclasses";
    };

    return Expr;

  })();

  WCTL.Arithmetic.AtomicExpr = (function(_super) {
    __extends(AtomicExpr, _super);

    function AtomicExpr(prop) {
      this.prop = prop;
    }

    AtomicExpr.prototype.stringify = function() {
      return this.prop;
    };

    AtomicExpr.prototype.evaluate = function(state) {
      return state.countProp(this.prop);
    };

    return AtomicExpr;

  })(WCTL.Arithmetic.Expr);

  WCTL.Arithmetic.ConstantExpr = (function(_super) {
    __extends(ConstantExpr, _super);

    function ConstantExpr(number) {
      this.number = number;
    }

    ConstantExpr.prototype.stringify = function() {
      return this.number;
    };

    ConstantExpr.prototype.evaluate = function(state) {
      return this.number;
    };

    return ConstantExpr;

  })(WCTL.Arithmetic.Expr);

  WCTL.Arithmetic.binOp = {
    '+': function(a, b) {
      return a + b;
    },
    '-': function(a, b) {
      return a - b;
    },
    '*': function(a, b) {
      return a * b;
    },
    '/': function(a, b) {
      return a / b;
    },
    '^': function(a, b) {
      return Math.pow(a, b);
    }
  };

  binOpToString = function(op) {
    var k, v, _ref;
    _ref = WCTL.Arithmetic.binOp;
    for (k in _ref) {
      v = _ref[k];
      if (v === op) {
        return k;
      }
    }
  };

  WCTL.Arithmetic.BinaryExpr = (function(_super) {
    __extends(BinaryExpr, _super);

    function BinaryExpr(expr1, expr2, op) {
      this.expr1 = expr1;
      this.expr2 = expr2;
      this.op = op;
    }

    BinaryExpr.prototype.stringify = function() {
      return "(" + (this.expr1.stringify()) + " " + (binOpToString(this.op)) + " " + (this.expr2.stringify()) + ")";
    };

    BinaryExpr.prototype.evaluate = function(state) {
      return this.op(this.expr1.evaluate(state), this.expr2.evaluate(state));
    };

    return BinaryExpr;

  })(WCTL.Arithmetic.Expr);

  WCTL.Arithmetic.UnaryMinusExpr = (function(_super) {
    __extends(UnaryMinusExpr, _super);

    function UnaryMinusExpr(expr) {
      this.expr = expr;
    }

    UnaryMinusExpr.prototype.stringify = function() {
      return "- " + (this.expr.stringify());
    };

    UnaryMinusExpr.prototype.evaluate = function(state) {
      return -this.expr.evaluate(state);
    };

    return UnaryMinusExpr;

  })(WCTL.Arithmetic.Expr);

}).call(this);
